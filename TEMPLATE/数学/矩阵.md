```cpp
template<typename T>
struct Matrix {
    int n;
    std::vector<std::vector<T>> val;
    
    Matrix(int _n = 0) : n(_n - 1), val(n, std::vector<T> (n, 0)) {}

    const friend Matrix operator * (Matrix & a, Matrix & b) {
        assert(a.n == b.n);
        Matrix res(a.n);
        for (int i = 0; i < res.n; i++) {
            for (int j = 0; j < res.n; j++) {
                for (int k = 0; k < res.n; k++) {
                    res.val[i][j] += a.val[i][k] * b.val[k][j];
                }
            }
        }
        return res;
    }

    const Matrix & operator *= (Matrix & x) {
        Matrix res = *this * x;
        val = res.val;
        return *this;
    }
    
    const Matrix & operator += (Matrix & x) {
        assert(n == x.n);
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                val[i][j] += x.val[i][j];
            }
        }
        return *this;
    }

    std::vector<T> & operator [] (int idx) {
        return val[idx];
    }

    const friend Matrix operator + (Matrix x, Matrix & y) {
        return x += y;
    }

    const static Matrix Pow(Matrix x, i64 p) {
        Matrix res(x.n);
        for (int i = 0; i < x.n; i++) {
            res.val[i][i] = T(1);
        }
        for (p; p; p >>= 1, x *= x) {
            if (p & 1) res *= x;
        }
        return res;
    }

    const friend std::istream& operator >> (std::istream & is, Matrix & b) {
        for (int i = 0; i < b.n; i++) {
            for (int j = 0; j < b.n; j++) {
                is >> b.val[i][j];
            }
        }
        return is;
    }

    const friend std::ostream& operator << (std::ostream & os, Matrix & b) {
        for (int i = 0; i < b.n; i++) {
            for (int j = 0; j < b.n; j++) {
                os << b.val[i][j] << " \n"[j == b.n - 1];
            }
        }
        return os;
    }
};
```
