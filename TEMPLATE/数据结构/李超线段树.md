```cpp
using ld  = long double;

template<class T = ld>
struct LiChaoSegmentTree {
    static constexpr ld eps = 1e-9;

    struct Line { 
        T k, b; 
    };

    int xmin, xmax;
    std::vector<Line> lines;   
    std::vector<int> seg;      

    LiChaoSegmentTree(int _xmin, int _xmax, int _n) : xmin(_xmin), xmax(_xmax) {
        lines.reserve(_n + 1);
        lines.emplace_back(0, (T)std::numeric_limits<ld>::lowest());
        seg.assign(4 * (xmax - xmin + 1) + 5, 0);
    }

    static int sgn(ld x) {
        if (fabsl(x) <= eps) {
            return 0;
        }
        return x > 0 ? 1 : -1;
    }

    ld value(int id, int x) const {
        return (ld)lines[id].k * (ld)x + (ld)lines[id].b;
    }

    int better(int a, int b, int x) const {
        if (a == 0) {
            return b;
        }
        if (b == 0) {
            return a;
        }
        ld ya = value(a, x), yb = value(b, x);
        int c = sgn(ya - yb);
        if (c != 0) {
            return c > 0 ? a : b;
        }
        return a < b ? a : b;
    }

    void insert1(int node, int l, int r, int id) {
        int &cur = seg[node];
        if (cur == 0) { 
            cur = id; return; 
        }
        int m = (l + r) >> 1, bm = better(id, cur, m);
        if (bm == id) {
            std::swap(id, cur);
        }
        if (l == r) {
            return;
        }
        bool L = (better(id, cur, l) == id), Mid = (better(id, cur, m) == id), R = (better(id, cur, r) == id);
        if (L != Mid) {
            insert1(node << 1, l, m, id);
        } else if (R != Mid) {
            insert1(node << 1 | 1, m + 1, r, id);
        }
    }

    void insert2(int node, int l, int r, int x, int y, int id) {
        if (y < l || r < x) {
            return;
        }
        if (x <= l && r <= y) {
            insert1(node, l, r, id);
            return;
        }
        int m = (l + r) >> 1;
        insert2(node << 1, l, m, x, y, id);
        insert2(node << 1 | 1, m + 1, r, x, y, id);
    }

    int add(int x0, T y0, int x1, T y1) {
        if (x0 > x1) { 
            std::swap(x0, x1); 
            std::swap(y0, y1); 
        }
        x0 = std::max(x0, xmin);
        x1 = std::min(x1, xmax);
        if (x0 > x1) {
            return 0;
        }
        if (x0 == x1) {
            lines.emplace_back(0, std::max(y0, y1));
        } else {
            T k = (y1 - y0) / (ld)(x1 - x0);
            lines.emplace_back(k, (y0 - (ld)k * (ld)x0));
        }
        int id = (int)lines.size() - 1;
        insert2(1, xmin, xmax, x0, x1, id);
        return id;
    }

    int add_line(T k, T b) {
        lines.emplace_back(k, b);
        int id = (int)lines.size() - 1;
        insert1(1, xmin, xmax, id);
        return id;
    }

    int query(int node, int l, int r, int x) const {
        int id = seg[node];
        if (l == r) return id;
        int m = (l + r) >> 1;
        if (x <= m) {
            return better(id, query(node << 1, l, m, x), x);
        } else {
            return better(id, query(node << 1 | 1, m + 1, r, x), x);
        }
    }

    int queryid(int x) const {
        return query(1, xmin, xmax, x);
    }

    ld queryval(int x) const {
        int id = query(1, xmin, xmax, x);
        return value(id, x);
    }
};
```
